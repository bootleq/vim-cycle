*cycle.txt*                                Cycle text to predefined candidates

Version:    1.0.0
Author:     bootleq <bootleq@gmail.com>
License:    Public Domain
Repository: https://github.com/bootleq/vim-cycle

==============================================================================
CONTENTS                                                      *cycle-contents*

    Introduction  .......................... |cycle-introduction|
    Usage  ................................. |cycle-usage|
    Configuration  ......................... |cycle-configuration|
      General options  ..................... |cycle-general-options|
      Define groups  ....................... |cycle-define-groups|
      Group options ........................ |cycle-group-options|
        regex .............................. |cycle-group-option-regex|
      Phased search  ....................... |cycle-phased-search|
      Fallback mapping  .................... |cycle-fallback-mapping|
      Examples  ............................ |cycle-examples|
    Limitations  ........................... |cycle-limitations|
    Credits  ............................... |cycle-credits|

==============================================================================
INTRODUCTION                                              *cycle-introduction*

*cycle* takes text near the cursor, replaces it with predefined alternatives.
Save your time when changing related words like true/false, Yes/No, and so on.

==============================================================================
USAGE                                                            *cycle-usage*

                                                             *<Plug>CycleNext*
                                                             *<Plug>CyclePrev*
Define key mappings for |<Plug>CycleNext| in |Normal| and |Visual| modes: >
  nmap <silent> <Leader>a <Plug>CycleNext
  vmap <silent> <Leader>a <Plug>CycleNext
< to replace the text-under-cursor or visual-selected-text. (This plugin
defines <Leader>a as default mapping)

You can add [count] to pick a candidate at further index instead of next ONE.
You can map |<Plug>CyclePrev| (Prev, not Next) to cycle in reverse direction.

For example, with items ["One", "Two", "Three"]
and your custom mappings are <C-A> for CycleNext, <C-X> for CyclePrev,
where the cursor is under "One", then:

    keys you type     result in ~
    -------------     --------- ~
      <C-A>             Two
      2<C-A>            Three
      <C-X>             Three
      4<C-X>            Three

This plugin has a very small set of preset groups (says, yes/no is a group).
It's recommended to define groups yourself, see |cycle-define-groups|.

There are some special features besides ordinary text replacement, which are
controlled by group options, see |cycle-group-options|.

You can use |.| to repeat last cycle if you have one of the following "repeat"
plugins installed:
- https://github.com/kana/vim-repeat
- https://github.com/tpope/vim-repeat


                                                           *<Plug>CycleSelect*
Another mapping, |<Plug>CycleSelect|, lists all candidates for choosing from.
You can define key mappings in |Normal| and |Visual| modes: >
  nmap <silent> <Leader>ga <Plug>CycleSelect
  vmap <silent> <Leader>ga <Plug>CycleSelect


Cycle([{class}, {dir}, {count}, {opts}])                             *Cycle()*

  You can use this function to trigger a cycle.
  {class} can be "w" or "v", which tells starting from a word, or visual mode.
  {dir} is the cycle direction.
  {count} is the cycle offset.
  {opts} is a dictionary which can contain:
    "groups"  Use specific groups instead of the groups added in ordinary way
              and internally maintained by this plugin.

CycleSelect([{class}, {opts}])                                 *CycleSelect()*

  You can use this function to trigger a cycle selection.
  See |Cycle()| about arguments.

==============================================================================
CONFIGURATION                                            *cycle-configuration*

------------------------------------------------------------------------------
General options                                        *cycle-general-options*

                                                              *g:loaded_cycle*
g:loaded_cycle            (default: none) ~

  Set to 1 to prevent this plugin from being loaded.

                                                      *g:cycle_default_groups*
g:cycle_default_groups    (default: none) ~

  This is a List for setting custom default groups. If set, no groups will be
  set by the plugin itself. See |cycle-define-groups-practice|.

                                       *g:cycle_default_groups_for_{filetype}*
g:cycle_default_groups_for_{filetype} ~
                          (default: none) ~

  Like |g:cycle_default_groups| but this List is loaded when 'filetype'
  changes, thus only available for the targeted filetype.

  The {filetype} part should be replaced with an actual type string, e.g.: >
    let g:cycle_default_groups_for_ruby = []
< is for filetype "ruby".

                                                      *g:cycle_filetype_links*
g:cycle_filetype_links    (default: none) ~

  With filetype-specific groups, you can define this variable to "link" a
  filetype, to allow it picking another filetype's effective groups.

  For example, you might want to use markdown groups for type "ghmarkdown". >
    let g:cycle_filetype_links = {
          \   'ghmarkdown': 'markdown',
          \   'typescriptreact': 'javascript',
          \ }
<
                                                         *g:cycle_no_mappings*
g:cycle_no_mappings       (default: 0) ~

  Set to 1 to disable default key mappings.
  List of defaults:

    mode   {lhs}         {rhs} ~
    ----   ---------     --------------- ~
    n      <Leader>a     <Plug>CycleNext
    v      <Leader>a     <Plug>CycleNext

                                                        *g:cycle_max_conflict*
g:cycle_max_conflict      (default: 1) ~

  When there are more than 1 alternates (in different groups) for current
  text, you are prompted to select which is the desired one.

  This feature is only enabled when this value is greater than 1.

  The default value is 1, which means no conflicts will be handled. This
  improves performance since no extra search is needed after first found.
  And it's recommended to use buffer-scoped groups to prevent conflicts, see
  |cycle-define-groups-practice|.

  When the number of conflicts exceeds this setting, no prompt will be shown,
  the cycle aborts with a message instead.

                                                           *g:cycle_select_ui*
g:cycle_select_ui      (default: "") ~

  Which prompt UI should be used for |<Plug>CycleSelect|.

  Can be set to one of the following:

      ui.select     Use nvim's |vim.ui.select()|.

      inputlist     Use Vim's |inputlist()|, input number and Enter to select.

      confirm       Use Vim's |confirm()|, type 1 character to select.

  or leave it empty; will try available methods in the above order.

  If the given method is not supported, will fallback to next one.

                                                         *g:cycle_conflict_ui*
g:cycle_conflict_ui      (default: "confirm") ~

  Like |g:cycle_select_ui|, but is used for "conflict" items selection.

                                                         *g:cycle_auto_visual*
g:cycle_auto_visual       (default: 0) ~

  When starting a cycle in normal mode, and the result text is not a keyword
  (for example, it contains whitespace, see 'iskeyword'), you might want to
  select the new text with visual mode. Set this option to 1 to enable it.

                                                       *g:cycle_naming_config*
g:cycle_naming_config     (default: none) ~

  A dictionary to customize the settings of "naming" matcher / changer (see
  |cycle-group-options| section). When absent, below defaults applied: >
  let g:cycle_naming_config = {
      \   'snake_case':           ['\v\l%(\l|\d)*%(_%(\l|\d)+)+'],
      \   'camelCase':            ['\v\l%(\l|\d)*%(\u%(\l|\d)*)+'],
      \   'camelCase_1':          ['\v\l%(\l|\d)*%(%(\u|_\d)%(\l|\d)*)+'],
      \   'kebab-case':           ['\v%(\l|\d)+%(-%(\l|\d)+)+'],
      \   'PascalCase':           ['\v%(\u+%(\l|\d)+)%(%(\u|\d)+%(\l|\d)+)*'],
      \   'PascalCase_1':         ['\v%(\u+%(\l|\d)+)%(%(\u|_\d)+%(\l|\d)+)*'],
      \   'SCREAMING_SNAKE_CASE': ['\v\u+%(_%(\u|\d)+)*'],
      \ }
< where the key is a "name" of convention, and value is a list of string
  {pattern} and optional dictionary {options}, the options can contain a "sub"
  key to specify a {sub} for internal |substitute()|.

                                                         *g:cycle_year_config*
g:cycle_year_config       (default: none) ~

  A dictionary to customize the setting of "year" matcher / changer (see
  |cycle-group-options| section). When absent, below defaults applied: >
  let g:cycle_year_config = {
        \   '民國': {'range': [1,  200], 'begin': 1912},
        \   '令和': {'range': [1,  200], 'begin': 2019},
        \   '平成': {'range': [1,   31], 'begin': 1989, 'end': 2019},
        \   '昭和': {'range': [1,   64], 'begin': 1926, 'end': 1989},
        \   '大正': {'range': [1,   15], 'begin': 1912, 'end': 1926},
        \   '明治': {'range': [1,   45], 'begin': 1868, 'end': 1912},
        \   'พ.ศ.': {'range': [1, 2700], 'begin': -543},
        \   'CE':   {},
        \ }
< where all non-CE systems must have a "begin" year relative to CE 1st. If the
  "end" is known then "end" should also be given. The "range" defines a
  boundary so the search doesn't need to consider longer string like "10000".

------------------------------------------------------------------------------
Define groups                                            *cycle-define-groups*

To start quickly, just read |cycle-define-groups-practice|.

                                                              *g:cycle_groups*
                                                              *b:cycle_groups*
All candidates are defined as groups.
The structure looks like:
>
  g:cycle_groups = [                | => groups, scoped by global/buffer
    {                               |   =>
      'items':   ['foo', 'bar'],    |   =>
      'options': {'hard_case': 1},  |   => a group
    },                              |   =>
  ],                                |
<
when |b:cycle_groups| exists, it takes higher priority than the global one.
|g:var| |b:var|

You should not define cycle_groups directly. Using |cycle#add_group()| is the
preferred way.

                                                        *cycle-default-groups*
Without any configuration, the default preset groups are: >
  call cycle#add_groups([
        \   [['true', 'false']],
        \   [['yes', 'no']],
        \   [['on', 'off']],
        \ ])
< note this will be ignored if any |g:cycle_default_groups| are configured.

                                                           *cycle#add_group()*
A group consists with "items" and optional "options".
To add a group, use |cycle#add_group()| with any of below forms: >
  cycle#add_group(items)
  cycle#add_group(items, options)
  cycle#add_group(items, option, ..., option_can_be_dictionary_or_string)
  cycle#add_group(group)
< for example: >
  call cycle#add_group(['Yes', 'No'])
  call cycle#add_group(['Yes', 'No'], {'match_case': 1})
  call cycle#add_group(['Yes', 'No'], 'match_case', {'hard_case': 1})
  call cycle#add_group([['Yes', 'No'], 'match_case'])
<
                                                         *cycle#parse_group()*
To translate a group from `add_group()` form (usually more human-friendly) to
its internal dictionary form. You can use `cycle#parse_group()` function. Note
it might return a list of groups because of shorthand group option expansion.

                                                         *cycle#add_b_group()*
Use cycle#add_b_group() to add a group into b: scoped. |b:cycle_groups|

                                                          *cycle#add_groups()*
                                                        *cycle#add_b_groups()*
To add multiple groups at the same time, there are shortcut versions of adding
functions. You have to wrap items and options as a List, for example: >
  call cycle#add_groups([
        \   [['true', 'false']],
        \   [['Yes', 'No'], 'match_case'],
        \ ])
<
                                                      *cycle#reset_b_groups()*
This clears |b:cycle_groups|.
Also accepts a parameter same as |cycle#add_b_groups| to set new groups.

                                                     *cycle#reset_ft_groups()*
Clear buffer-scoped groups for filetypes, reset to the setting for current
'filetype' (predefined by |g:cycle_default_groups_for_{filetype}|).

This function will be called automatically when 'filetype' change.

                                          *cycle#reset_b_groups_by_filetype()*
Deprecated, will be removed in future version.
Reason: now we hold ft-specified groups in another internal variable, no
longer use |b:cycle_groups|.

Reset |b:cycle_groups| with settings subject to current 'filetype', requires
variable |g:cycle_default_groups_for_{filetype}| preset.

                                                *cycle-define-groups-practice*
The recommended way to define groups is setting |g:cycle_default_groups| and
|g:cycle_default_groups_for_{filetype}| in your vimrc, this plugin will find
and applied them behind the scene.
See |cycle-config-examples|.

------------------------------------------------------------------------------
Group options                                            *cycle-group-options*

A group option is a Dictionary with a key-value pair. While for convenience,
in |cycle#add_group()| and similar functions, you can set it as a string
(using its key), and the option's default value will be used.

By default no options are set.

"name"              String (default: none) ~

  Name of the group.
  Will be displayed in conflict prompt, see |g:cycle_max_conflict|.

"match_case"        Number (default: 0) ~

  By default, searching of group items is case-insensitive. Thus "yes" and
  "Yes" have identical effect.
  Set this option other than 0 to enforce case-sensitive search.

"hard_case"         Number (default: 0) ~

  By default, the case in the original text will be copied to the resulting
  text. Thus "friDAY" will become "satURDay".
  Set this option other than 0 to keep resulting text with the same case as
  they were defined.

"sub_tag"           Number (default: 1) ~

  When editing a xml tag, opening and closing parts can be substituted
  together: >
    <EM>example</EM>  =>  <STRONG>example</STRONG>
< Set this option other than 0 to enable it.

"sub_pair"          Number (default: 1) ~

  When editing special pairs (e.g.: {}, <>), opening and closing parts can be
  substituted together: >
    {example}  =>  <example>
< You have to set this option other than 0 and define "end_with" or
  "start_with" option to recognize what the opposite part is.
  Example: >
    call cycle#add_group(
          \   [ '{', '<' ], 'sub_pair', {'end_with': [ '}', '>' ]}
          \ )
< It's recommended to use "sub_pairs" rather than this option.

"end_with"          List (default: none) ~
"begin_with"        List (default: none) ~

  Used with "sub_pair" option, to define opposite pairs for original text.

"sub_pairs"         String (default: ':') ~

  This is a shortcut to set "sub_pair", "end_with" and "begin_with" options at
  the same time. Each group item will be split with this value into "begin"
  and "end" parts.
  Example: >
    call cycle#add_group(
          \   [ '{:}', '<:>' ], 'sub_pairs'
          \ )
< Internally, this group will be translated into two groups, just identical to
  the original 'sub_pair' version.

  Identical Pairs:

  It is possible to set `sub_pairs` with the same character on both sides. For
  example `":"`. This will try different methods to find the position of
  another side and doesn't always work (depending on the situation).

  Current finding methods are:

  1. treesitter range (if available)
  2. Vim's builtin vi' vi" vi` text objects |iquote|
  3. a search function mimics vi' series, used for other characters

  And have below behaviors or limitations:

  - Identical pair can only contain 1 character.
  - If can't find another side, will still cycle as it is the beginning side.

"before_sub"        (List) ~
"after_sub"         (List) ~
"ambi_pair"         (List) ~
"restrict_cursor"   (Number) ~

  Internal usage only, don't set them.

"match_word"        Number (default: none) ~

  Restrict group items to be matched within a word boundary, see 'iskeyword'.
  For example, on/off only matches "on" but not "Mon".
  Set this option other than 0 to enforce word-bounded search.

  This option has no effect in "regex" matcher.
  In "naming" matcher, the 'iskeyword' option is always set to "@,48-57,-,_".

"matcher"           string | Dict (default: none) ~

  Take different strategy to match group items.
  Available options:

  regex   Each group item is not an literal string, but a Vim regexp
          |pattern|. An item is matched when the cursor is within the match.
          Shoule be used with related options, see |cycle-group-option-regex|
          for details.

  naming  Each group item is a "name" of a naming convention. If the text
          under the cursor matches the convention, transform it to the next
          style. Current supported items: >
          snake_case, camelCase, camelCase_1, kebab-case,
          PascalCase, PascalCase_1, SCREAMING_SNAKE_CASE
<
          The `_1` suffixed variants were used to "keep" segments consist with
          only numbers, avoid them from being absorbed during transform. For
          example `COVID_19` -> `Covid19` is non-reversible, while with
          `camelCase_1`, it changes to `Covid_19` where the number is split.

  year    Match CE (Common Era) years like `2024` or year notation in other
          calendar era systems like `民國 103` . Each group item is not an
          literal string but an era system. Current support items: >
          民國, 令和, 平成, 昭和, 大正, 明治, พ.ศ., CE
<         'CE' must be put at the last position to avoid overshadow others.

  {dict}  You can provide custom "test" function for matcher. Set this option
          to a dict with `test` key pointer to the function name or Funcref.

  A matcher should implement `cycle#matcher#{name}#test()` to cover the group
  search job.

  With custom matcher, other group options might not work.

"changer"           string | Dict (default: none) ~

  Take different strategy to change matched item.
  Available options:

  regex   Do not replace item by directly cycle to "next" item, but find a
          corresponding {sub} (of |substitute()|) from regex:"to" option, use
          it to substitute the matched portion. Shoule be used with related
          options, see |cycle-group-option-regex| for detail.

  naming  Convert text by applying next naming convention.

  year    Convert matched year to next calendar era system.
          If a calculated year is invalid (e.g., outside the range of a known
          historical era), discard the result and try the next item.

  {dict}  You can provide custom `#change` functions for changer. Set this
          option to a dict with `change` key pointer to the function name or
          Funcref.

  A changer should implement `cycle#changer#{name}#change()` to change an
  matched item. And `cycle#changer#{name}#collect_selections()` to prepare
  candidates for CycleSelect UI.

  With custom changer, other group options might not work.

                                                    *cycle-group-option-regex*
"regex"             (Dict) (default: none) ~

  This provides detailed info for working together with "matcher" and
  "changer" when type are set to the "regex" strategy. Example usage: >

    [[':\(\k\+\)\s*=>\s*', '\<\(\k\+\): '], #{regex: ['\1: ', ':\1 => ']}]

< expands to: >

    [[':\(\k\+\)\s*=>\s*', '\<\(\k\+\): '], #{
      \   matcher: 'regex',
      \   changer: 'regex',
      \   regex: {
      \     'to': ['\1: ', ':\1 => '],
      \   }
      \ }]
<
  This mimics the way switch.vim works.
  https://github.com/AndrewRadev/switch.vim
  In fact above rules were derived from one of switch.vim's builtin: >
    \   'ruby_hash_style': {
    \     ':\(\k\+\)\s*=>\s*': '\1: ',
    \     '\<\(\k\+\): ':      ':\1 => ',
    \   },
< which cycles between `foo:` and `:foo =>`.

  Many useful patterns are only achievable with this feature.

  "regex" dictionary can contain props:

  - "to"             (List | Dict) (default: none) ~

    Defines how a matched pattern should be substituted. It should have the
    same number of group items, and each pattern is used for the item at the
    same index (not for the "next" item as you might expect in a usual cycle).

    For example, items: `['x\(\d\)x', 'o\(\d\)o']`  can have settings like
                    to: `['o\1o',     'x\1x']`
        to change item: `x4x` => `o4o`

    Can also be set as a |Dict| like switch.vim's "nested dict definition",
    the matched text will be globally substituted with {pattern} and {sub}
    comes from the dict's key and value. For example: >
      [['\<[a-z0-9]\+_\k\+\>'],
        #{regex: {
          'to': { '_\(.\)': '\U\1' },
        }]
<   the text `foo_bar_baz` will be matched as `foo_bar_baz` (whole string),
    then conceptually a `substitute('_\(.\)', '\U\1')` is run on the matched
    text and result to `fooBarBaz`.

    Limitation: ~
    Cycle operations do substitute on "matched" text rather than directly on
    text in buffer, which means patterns like |\_||\@<=||\%'m||\%23c| can be
    found, but can not be substitute (matched text can't be matched again).
    See |cycle-group-option-regex-subp| for rescue.

                                               *cycle-group-option-regex-subp*
  - "subp"           (List) (default: none) ~

    Provides looser "sub patterns" for "matched" text. Refer to the Limitation
    section of "to" as reason. For example: >
      [['\(ex-\)\@<=\(\k\+\)'],
        #{regex: {
          'to': ['OK'],
          'subp': ['\(\k\+\)'],
        }]
<   can successfully cycle "ex-friend" to "OK". Without "subp" it doesn't.

                                     *cycle#group_converter#regex_dict_list()*
  Hint: you can use `cycle#group_converter#regex_dict_list()` to convert
  `switch_custom_definitions` list to cycle groups. However, remember to check
  the order of items, because Vim |Dictionary| doesn't have a specific
  ordering, incorrect order can break CycleSelect option generation.

"naming"            Number (default: none) ~

  This is merely a shorthand for "naming" matcher/changer. It expands to: >
    #{matcher: 'naming', changer: 'naming'}

"year"              Number (default: none) ~

  This is merely a shorthand for "year" matcher/changer. It expands to: >
    #{matcher: 'year', changer: 'year'}
<
"cond"              Funcref (default: none) ~

  Condition, a group will not match if this function doesn't returns true.
  The function receives 2 arguments:
    - group: the group dictionary.
    - tick: an internal number (starts from 0) which increases every time
            doing search. Can be used to memorize function results (cache).
  This function runs "before" each group item's matching.
  Example: >
    " Do not cycle [ ==, != ] when not in lua language (lua uses ~=)

    let s:cycle_tick = -1
    let s:cycle_not_lua_cache = v:false

    function! s:not_lua_context(group, tick) abort " {{{
      if s:cycle_tick == a:tick
        return s:cycle_not_lua_cache
      endif

      let result = &filetype != 'lua'

      if exists('*v:lua.vim.inspect_pos') " nvim treesitter
        let hl = v:lua.vim.inspect_pos()
        let ts_lang = v:lua.vim.tbl_get(hl, 'treesitter', 1, 'lang')
        if ts_lang
          let result = ts_lang != 'lua'
        endif
      endif

      let s:cycle_tick = a:tick
      let s:cycle_not_lua_cache = result
      return result
    endfunction " }}}

    let g:cycle_default_groups += [
      \   [['==', '!='], { 'cond': function('s:not_lua_context') }],
      \ ]
<
"hints"             List (default: none) ~

  UI hint for each item.
  Will be displayed in |CycleSelect()| or a conflict prompt. The list contains
  string values, each corresponding to a group item. >
      \   [['snake_case', 'SCREAMING_SNAKE_CASE'],
      \     {'hints': ['snake_case', 'MACRO_CASE'}]}],
< results in select UI like: >
      Cycle to:
        A) => foo_bar_baz      snake_case
        B) => FOO_BAR_BAZ      MACRO_CASE
<
------------------------------------------------------------------------------
Phased Search                                            *cycle-phased-search*

Sometimes the target text is not identical to |<cword>|, for example a group
item "Hello World" with the cursor being put at the space between words.

This plugin will try to guess what you want in several phases. For example it
checks current multibyte char at cursor, then |<cword>|, then a line search.

To cycle on an exactly known area, please visual-select the text first.

------------------------------------------------------------------------------
Fallback mapping                                      *cycle-fallback-mapping*

When |<Plug>CycleNext| or |<Plug>CyclePrev| fails to find any matched
alternates, some key sequences can be set as fallbacks.
                                                     *<Plug>CycleFallbackNext*
                                                     *<Plug>CycleFallbackPrev*
For example, define below mappings: >
  noremap <silent> <Plug>CycleFallbackNext <C-A>
  noremap <silent> <Plug>CycleFallbackPrev <C-X>
< then Vim defult |Ctrl-A| (adding) or |Ctrl-X| (subtracting) will be
performed, if there were nothing to cycle.

Note that you will have to use |map| instead of |noremap| if the fallback key
needs further remapping. e.g.: >
  map <silent> <Plug>CycleFallbackNext <Plug>SpeedDatingUp
<

------------------------------------------------------------------------------
Configuration examples:                                 *cycle-config-examples*

General options:
>
    let g:cycle_no_mappings = 1
    let g:cycle_max_conflict = 1
    let g:cycle_select_ui = 'ui.select'
    let g:cycle_conflict_ui = 'confirm'
<

Key mappings:
>
    nmap <silent> <LocalLeader>a <Plug>CycleNext
    vmap <silent> <LocalLeader>a <Plug>CycleNext
    nmap <silent> <Leader>a <Plug>CyclePrev
    vmap <silent> <Leader>a <Plug>CyclePrev
    noremap <silent> <Plug>CycleFallbackNext <C-A>
    noremap <silent> <Plug>CycleFallbackPrev <C-X>

    nmap <silent> <LocalLeader>ga <Plug>CycleSelect
    vmap <silent> <LocalLeader>ga <Plug>CycleSelect
<

Global groups:
>
    let g:cycle_default_groups = [
          \   [['true', 'false']],
          \   [['yes', 'no']],
          \   [['on', 'off'], 'match_word'],
          \   [['+', '-']],
          \   [['>', '<']],
          \   [['"', "'"]],
          \   [['==', '!=']],
          \   [['0', '1']],
          \   [['and', 'or']],
          \   [["in", "out"]],
          \   [["up", "down"]],
          \   [["min", "max"]],
          \   [["get", "set"]],
          \   [["add", "remove"]],
          \   [["to", "from"]],
          \   [["read", "write"]],
          \   [["only", "except"]],
          \   [['without', 'with']],
          \   [["exclude", "include"]],
          \   [["asc", "desc"]],
          \   [['是', '否']],
          \   [['在', '再']],
          \   [['{:}', '[:]', '(:)'], 'sub_pairs'],
          \   [['（:）', '「:」', '『:』'], 'sub_pairs'],
          \   [['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
          \     'Friday', 'Saturday'], 'hard_case', {'name': 'Days'}],
          \ ]

    " Year cycle
    let g:cycle_default_groups == [
          \   [['民國', '令和', '平成', '昭和', '大正', 'พ.ศ.', 'CE'], 'year'],
          \ ]
          " Note that 'CE' must be put at the end.

    " ruby, rails
    let g:cycle_default_groups += [
          \   [["if", "unless"]],
          \   [["blank", "present"]],
          \   [["while", "until"]],
          \   [["begin", "end"]],
          \   [["foreign_key", "primary_key"]],
          \   [["inspect", "to_yaml"]],
          \ ]

    " CSS
    let g:cycle_default_groups += [
          \   [["none", "block"]],
          \   [["show", "hide"]],
          \   [["left", "right"]],
          \   [["top", "bottom"]],
          \   [["margin", "padding"]],
          \   [["before", "after"]],
          \   [["absolute", "relative"]],
          \   [["first", "last"]],
          \ ]

    " HTML
    let g:cycle_default_groups += [
          \   [['h1', 'h2', 'h3'], 'sub_tag'],
          \   [['ul', 'ol'], 'sub_tag'],
          \   [['em', 'strong', 'small'], 'sub_tag'],
          \ ]
<

Filetype specified groups:
>
    let g:cycle_filetype_links = {
          \   'ghmarkdown': 'markdown',
          \ }

    " ruby only
    let g:cycle_default_groups_for_ruby = [
          \   [['accessible', 'protected']],
          \   [['stylesheet_link_tag ', 'javascript_include_tag ']],
          \ ]

    " " demo how to convert 'switch.vim' definition:
    " " This cycles "foo" / 'foo' / :foo
    " let switch_vim_ruby_keyword_string = {
    "     \   '"\(\k\+\%([?!]\)\=\)"':                '''\1''',
    "     \   '''\(\k\+\%([?!]\)\=\)''':              ':\1',
    "     \   ':\(\k\+\%([?!]\)\=\)\@>\%(\s*=>\)\@!': '"\1"\2',
    "     \ }
    " let switch_demo_definitions = [switch_vim_ruby_keyword_string]
    " let groups = cycle#group_converter#regex_dict_list(switch_demo_definitions)
    " " due to Dict ordering issue, you should check above result and write down
    " " manually:
    let g:cycle_default_groups_for_ruby += [
      \   [[
      \     '"\(\k\+\%([?!]\)\=\)"',
      \     '''\(\k\+\%([?!]\)\=\)''',
      \     ':\(\k\+\%([?!]\)\=\)\@>\%(\s*=>\)\@!'
      \    ], #{regex: [
      \                 '''\1''',
      \                 ':\1',
      \                 '"\1"\2'
      \    ]}]
      \ ]

    " plaintex only
    let g:cycle_default_groups_for_plaintex = [
          \   [
          \     '\left(:\right)',
          \     '\mleft(:\mright)',
          \     '\Bigl(:\Bigr)',
          \     '(:)',
          \   ],
          \   'sub_pairs', 'hard_case', 'match_case'
          \ ]
          " Note (:) must be put at the end. The search runs in sequence;
          " an earlier ( match can short-circuit the following items.

    " markdown only
    let g:cycle_default_groups_for_markdown = [
          \   [['^\(\s*\)- \[ \] ', '^\(\s*\)- \[x\] '],
          \    #{regex: ['\1- [x] ', '\1- [ ] '],
          \    name: 'Markdown task checkbox'}],
          \ ]
<
Set another set of groups, trigger by different mappings:
>
    let s:tx_groups = [
          \   [['snake_case', 'kebab-case', 'camelCase_1', 'PascalCase_1',
          \     'SCREAMING_SNAKE_CASE'], 'naming'],
          \ ]

    function! s:cycle_tx_groups() abort " {{{
      let groups = s:tx_groups
      " ... can do more dynamic handling to make your groups

      " Must translate to internal format
      let parsed = map(deepcopy(groups), {i, g -> cycle#parse_group(g)})
      let parsed = flatten(parsed)
      return #{groups: parsed}
    endfunction " }}}

    nnoremap <silent> <LocalLeader>x
          \ <Cmd>call Cycle('w', 1, v:count1, <SID>cycle_tx_groups())<CR>
    vnoremap <silent> <LocalLeader>x
          \ <Cmd>call Cycle('v', 1, v:count1, <SID>cycle_tx_groups())<CR>
    nnoremap <silent> <LocalLeader>gx
          \ <Cmd>call CycleSelect('w', <SID>cycle_tx_groups())<CR>
    vnoremap <silent> <LocalLeader>gx
          \ <Cmd>call CycleSelect('v', <SID>cycle_tx_groups())<CR>
<
==============================================================================
LIMITATIONS                                                *cycle-limitations*

- Can't handle multi line text.

==============================================================================
CREDITS                                                        *cycle-credits*

- Michael Brown ~
  Author of SwapIt.vim: https://github.com/mjbrownie/swapit
  SwapIt originally provides lots of awesome features include visual
  multi-words, xml tag pairs, omni-completion cycling.

- Andrew Radev ~
  Author of switch.vim https://github.com/AndrewRadev/switch.vim
  The "regex" strategy's crucial first search('bcW') detection is learned from
  switch.vim.

==============================================================================
vim:tw=78:fo=tcroq2mM:et:sts=2:sw=2:ft=help:norl:
