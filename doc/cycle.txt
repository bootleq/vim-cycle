*cycle.txt*                                Cycle text to predefined candidates

Version:    0.0.0
Author:     bootleq <bootleq@gmail.com>
License:    Public Domain
Repository: https://github.com/bootleq/vim-cycle

==============================================================================
CONTENTS                                                      *cycle-contents*

    Introduction  .......................... |cycle-introduction|
    Usage  ................................. |cycle-usage|
    Configuration  ......................... |cycle-configuration|
      General options  ..................... |cycle-general-options|
      Define groups  ....................... |cycle-define-groups|
      Group options ........................ |cycle-group-options|
      Examples  ............................ |cycle-examples|
    Known issues  .......................... |cycle-known-issues|
    Credits  ............................... |cycle-credits|

==============================================================================
INTRODUCTION                                              *cycle-introduction*

*cycle* takes text near cursor, replace it with predefined alternates. Save
your time from changing relative words like true/false, Yes/No, and so on.

==============================================================================
USAGE                                                            *cycle-usage*

                                                             *<Plug>CycleNext*
                                                             *<Plug>CyclePrev*
Define key mapping for |<Plug>CycleNext| in |normal-mode|, >
  nmap <silent> <LocalLeader>a <Plug>CycleNext
< use it to replace text under cursor.
(there is a default mapping <LocalLeader>a for this)

Also map it in |visual-mode|, >
  vmap <silent> <LocalLeader>a <Plug>CycleNext
< this replaces visual selected text, e.g.: "Hello World".

You can add [count] to pick candidate at further index, instead of just Next.
You can map |<Plug>CyclePrev| (Prev, not Next) to cycle in reverse direction.

For example, with group ["One", "Two", "Three"]
and your custom mapping is <C-A> for CycleNext, <C-X> for CyclePrev,
where the cursor is under "One", then

    keys you type     result in ~
    -------------     --------- ~
      <C-A>             Two
      2<C-A>            Three
      <C-X>             Three
      4<C-X>            Three

This plugin has a very small set of preset groups (says, yes/no is a group).
It's recommended to define groups by yourself, see |cycle-define-groups|.

There are some special features beside ordinary text replacing. They are
controlled by group options, see |cycle-group-options|.

==============================================================================
CONFIGURATION                                            *cycle-configuration*

------------------------------------------------------------------------------
General options                                        *cycle-general-options*

                                                              *g:loaded_cycle*
g:loaded_cycle            (default: none) ~

  Set to 1 to prevent this plugin from being loaded.

                                                      *g:cycle_default_groups*
g:cycle_default_groups    (default: none) ~

  This is a List for setting custom default groups. If this option exists, no
  groups will be set by plugin itself. See |cycle-define-groups-practice|.

                                                         *g:cycle_no_mappings*
g:cycle_no_mappings       (default: 0) ~

  Set to 1 to disable default key mappings.
  There is only one default: <LocalLeader>a for |<Plug>CycleNext|.

                                                        *g:cycle_max_conflict*
g:cycle_max_conflict      (default: 1) ~

  When there are more than 1 alternates (in different groups) for current
  text, you are prompted to select which one you want.

  When the number of conflicts is more than this value, no prompt will be
  shown, just abort with a message instead.

  The default value is 1, means no conflicts will be handled. This improve
  some performance since no extra search is needed after first found.
  And it's recommended to use buffer-scoped groups for decrease conflicts, see
  |cycle-define-groups-practice|.

                                                         *g:cycle_auto_visual*
g:cycle_auto_visual       (default: 0) ~

  When starting a cycle in normal mode, and the result text is not a keyword
  (for example, it contains whitespace, see |iskeyword|), you might want to
  select the new text with visual mode. Set this option to 1 to enable it.

                                                       *g:cycle_phased_search*
g:cycle_phased_search     (default: 1) ~

  When starting a cycle, it might not obviously know which text should be
  cycled. In most cases it's exactly the |<cword>| under cursor, however, for
  example, to cycle "Hello World", we must visual select it because it's not a
  <cword>.

  When this option is on, some smart guess will perform. The search can retry
  with multiple phases. For example, while searching of <cword> in
  "foo_with_bar" fails, some secondary search can find the "with" and return
  the intended "foo_without_bar" as a result.

------------------------------------------------------------------------------
Define groups                                            *cycle-define-groups*

To start quickly, just read |cycle-define-groups-practice|.

                                                              *g:cycle_groups*
                                                              *b:cycle_groups*
All candidates are defined as a set of groups, a List of group settings.
Structure of groups looks like:
>
  g:cycle_groups = [                | => groups, scoped by global or buffer
    {                               |   =>
      'items':   ['foo', 'bar'],    |   =>
      'options': {'hard_case': 1},  |   => a group
    },                              |   =>
  ],                                |
<
when there exists |b:cycle_groups|, it takes higher priority than the global
one. |g:var| |b:var|

You should not define cycle_groups directly. Use |cycle#add_group()| is the
prefered way.

                                                        *cycle-default-groups*
Without any configuration, the default preset groups is: >
  call cycle#add_groups([
        \   [['true', 'false']],
        \   [['yes', 'no']],
        \   [['on', 'off']],
        \   [['and', 'or']],
        \   [["in", "out"]],
        \   [['+', '-']],
        \   [['>', '<']],
        \ ])
<
                                                           *cycle#add_group()*
A group consists with "items" and optional "options".
To add a group, using |cycle#add_group()| with any of below forms >
  cycle#add_group(items)
  cycle#add_group(items, options)
  cycle#add_group(items, option, ..., option_can_be_dictionary_or_string)
  cycle#add_group(group)
< for example: >
  call cycle#add_group(['Yes', 'No'])
  call cycle#add_group(['Yes', 'No'], {'match_case': 1})
  call cycle#add_group(['Yes', 'No'], 'match_case', {'hard_case': 1})
  call cycle#add_group([['Yes', 'No'], 'match_case'])
<
                                                         *cycle#add_b_group()*
Use cycle#add_b_group() to add a group into b: scoped.

                                                          *cycle#add_groups()*
                                                        *cycle#add_b_groups()*
To add multiple groups at the same time, There are shortcut version of adding
functions. You have to wrap items and options as a List, for example: >
  call cycle#add_groups([
        \   [['true', 'false']],
        \   [['Yes', 'No'], 'match_case'],
        \ ])
<
                                                *cycle-define-groups-practice*
The recommended way to define groups is set |g:cycle_default_groups| in your
vimrc, and add buffer-specified groups with autocommands.
See |cycle-config-examples|.

------------------------------------------------------------------------------
Group options                                            *cycle-group-options*

A group option is a Dictionary with key-value pair. While for convenience,
within |cycle#add_group()| and similar functions, you can set it as a string
(by its key), the option's default value will be used.

By default no options are set.

"name"              String (default: none) ~

  Name of the group.
  Will be displayed in the conflict prompt, see |g:cycle_max_conflict|.

"match_case"        Number (default: 1) ~

  By default, searching of group items is case-insensitive. Thus "yes" and
  "Yes" have identical effect.
  Set this option other than 0 to enforce case-sensitive search.

"hard_case"         Number (default: 1) ~

  By default, case in original text will be copied to resulting text. Thus
  "friDAY" will become "satURDay".
  Set this option other than 0 to keep resulting text with the same case as
  they were defined.

"sub_tag"           Number (default: 1) ~

  When editing a xml tag, opening and closing parts can be substituted
  together: >
    <EM>example</EM>  =>  <STRONG>example</STRONG>
< Set this option other then 0 to enable it.

"sub_pair"          Number (default: 1) ~

  When editing special pairs (e.g.: {}, <>), opening and closing parts can be
  substituted together: >
    {example}  =>  <example>
< You have to set this option other than 0 and define "end_with" or
  "start_with" option to recognize what the opposite part is.
  Example: >
    call cycle#add_group(
          \   [ '{', '<' ], 'sub_pair', {'end_with': [ '}', '>' ]}
          \ )
< It's recommended to use "sub_pairs" other than this option.

"end_with"          List (default: none) ~
"begin_with"        List (default: none) ~

  These two are used with "sub_pair" option, to define the opposite pairs for
  original text.

"sub_pairs"         String (default: ':') ~

  This is a shortcut to set "sub_pair", "end_with" and "begin_with" options at
  the same time. Each group item will be split with this value into "begin"
  and "end" parts.
  Example: >
    call cycle#add_group(
          \   [ '{:}', '<:>' ], 'sub_pairs'
          \ )
< Internally, this group will be translated into two groups, just identical
  with original 'sub_pair' version.

"before_sub"        (List) ~
"after_sub"         (List) ~
"restrict_cursor"   (Number) ~

  Internal usage only, don't set them.

------------------------------------------------------------------------------
Configuration examples:                                 *cycle-config-examples*

General options:
>
    let g:cycle_no_mappings = 1
    let g:cycle_max_conflict = 1
    let g:cycle_phased_search = 1
    nmap <silent> <LocalLeader>a <Plug>CycleNext
    vmap <silent> <LocalLeader>a <Plug>CycleNext
<

Default global groups:
>
    let g:cycle_default_groups = [
          \   [['true', 'false']],
          \   [['yes', 'no']],
          \   [['on', 'off']],
          \   [['and', 'or']],
          \   [['+', '-']],
          \   [['>', '<']],
          \   [['"', "'"]],
          \   [['==', '!=']],
          \   [['0', '1']],
          \   [['是', '否']],
          \   [["in", "out"]],
          \   [["min", "max"]],
          \   [["get", "post"]],
          \   [["to", "from"]],
          \   [["only", "except"]],
          \   [['with', 'without']],
          \   [["exclude", "include"]],
          \   [["asc", "desc"]],
          \   [['{:}', '[:]', '(:)'], 'sub_pairs'],
          \   [['（:）', '「:」', '『:』'], 'sub_pairs'],
          \   [['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
          \     'Friday', 'Saturday'], 'hard_case', {'name': 'Days'}],
          \ ]

    " ruby, rails
    let g:cycle_default_groups += [
          \   [["if", "unless"]],
          \   [["blank", "present"]],
          \   [["while", "until"]],
          \   [["begin", "end"]],
          \   [["foreign_key", "primary_key"]],
          \   [["inspect", "to_yaml"]],
          \   [["add_column", "remove_column"]],
          \ ]

    " CSS
    let g:cycle_default_groups += [
          \   [["none", "block"]],
          \   [["show", "hide"]],
          \   [["left", "right"]],
          \   [["top", "bottom"]],
          \   [["margin", "padding"]],
          \   [["before", "after"]],
          \   [["absolute", "relative"]],
          \   [["first", "last"]],
          \ ]

    " HTML
    let g:cycle_default_groups += [
          \   [['h1', 'h2', 'h3'], 'sub_tag'],
          \   [['ul', 'ol'], 'sub_tag'],
          \   [['em', 'strong', 'i', 's', 'del', 'small'], 'sub_tag'],
          \ ]
<

Buffer specified groups:
>
    TODO
<

==============================================================================
KNOWN ISSUES                                              *cycle-known-issues*

- Can't handle multi line text.

==============================================================================
CREDITS                                                        *cycle-credits*

- Michael Brown ~
  Author of SwapIt.vim: https://github.com/mjbrownie/swapit
  SwapIt originally provides lots of awesome features include visual
  multi-words, xml tag pairs, omni-completion cycling.


==============================================================================
vim:tw=78:fo=tcroq2mM:et:sts=2:sw=2:ft=help:norl:
