Describe Sub pairs
  Before each
    call cycle#test#reset_default_groups([
          \   [["do:end", "{:}"], 'sub_pairs'],
          \   [["「:」", "【『:』】"], 'sub_pairs'],
          \   [[ '[', '<' ], 'sub_pair', {'end_with': [ ']', '>' ]}],
          \   [[ ']', '>' ], 'sub_pair', {'begin_with': [ '[', '<' ]}],
          \   [["':'", '":"', '`:`', '|:|', "“:”"], 'sub_pairs'],
          \ ])
    new
  End

  After each
    bwipeout!
  End

  It respects "sub_pair" and "end_with"
    let line = '<= [1, 2, 3] < [a, b, c] -----> >'
               "             B
    call setline(1, line)

    call search('< [a', 'W') " begin of second <
    execute 'normal \a'
    Assert Equals(getline(1), '<= [1, 2, 3] [ [a, b, c] -----] >')
                              "             B                E
    execute 'normal \a'
    Assert Equals(getline(1), line)
  End

  It respects "sub_pair" and "begin_with"
    let line = '<= [1, 2, 3] < [a, b, c] -----> >'
               "                       E
    call setline(1, line)

    call search('] --', 'W') " end of second [ ... ]
    execute 'normal \a'
    Assert Equals(getline(1), '<= [1, 2, 3] < <a, b, c> -----> >')
                              "               B       E
    execute 'normal \a'
    Assert Equals(getline(1), line)
  End

  Context sub_pairs with non-keyword text like LaTex
    Before each
      call cycle#test#reset_default_groups([[
            \   [
            \     '\left(:\right)',
            \     '\mleft(:\mright)',
            \     '\Bigl(:\Bigr)',
            \     '(:)',
            \   ],
            \   'sub_pairs', 'hard_case', 'match_case'
            \ ]])
    End

    It sub_pairs, from begin, sub end
      let line = '(a+b)'
      call setline(1, line)

      execute 'normal \a'
      Assert Equals(getline(1), '\left(a+b\right)')
      execute 'normal \a'
      Assert Equals(getline(1), '\mleft(a+b\mright)')

      call cursor(1, 4) " on 'e' of \mleft
      execute 'normal \a'
      Assert Equals(getline(1), '\Bigl(a+b\Bigr)')
      Assert Equals(col('.'), 4)

      call cursor(1, 6) " on '(' of \mBigl(
      execute 'normal \a'
      Assert Equals(getline(1), '(a+b)')
      Assert Equals(col('.'), 1)
    End

    It sub_pairs, from end, sub begin
      let line = '(a+b)'
      call setline(1, line)

      normal! $
      execute 'normal \a'
      Assert Equals(getline(1), '\left(a+b\right)')
      Assert Equals(col('.'), searchpos('\\right')[1], 'Expect cursor at the beginning of \right')

      execute 'normal \a'
      Assert Equals(getline(1), '\mleft(a+b\mright)')
      Assert Equals(col('.'), searchpos('\\mright')[1])
    End
  End

  Context sub_pairs with multibyte characters
    Before each
      let lines =<< trim END
        1 I don't always 」！「
        2 but when I do,
        3 it「ends」weekend
      END
      call setline(1, lines)
    End

    It in the same line
      call cursor([3, 1])
      call search('」')
      execute 'normal \a'
      Assert Equals(getline(3), "3 it【『ends』】weekend")
      Assert Equals(col('.'), searchpos('』', 'cnW')[1])

      execute 'normal \a'
      Assert Equals(getline(3), "3 it「ends」weekend")
      Assert Equals(col('.'), searchpos('」', 'cnW')[1])
    End

    It across lines
      call cursor([1, 1])
      call search('don')
      execute 'normal \a'
      Assert Equals(getline(1), "1 I {n't always 」！「")
      Assert Equals(getline(3), "3 it「ends」week}")
      Assert Equals(col('.'), searchpos('{', 'cnW')[1])

      execute 'normal \a'
      Assert Equals(getline(1), "1 I don't always 」！「")
      Assert Equals(getline(3), "3 it「ends」weekend")
      Assert Equals(col('.'), searchpos('don', 'cnW')[1])
    End
  End

  Context sub_pairs with identical pairs
    Context by vi" series text objects / or search mimics it (|)
      Before each
        let lines =<< trim END
          1 foo "bar \" "   " baz
          2 foo “中文”
          3 orphaned " land
        END
        call setline(1, lines)
      End

      It from begin, sub end
        call search('"bar')

        execute 'normal \a'
        Assert Equals(getline(1), '1 foo `bar \" `   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo |bar \" |   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo “bar \" ”   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo ''bar \" ''   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo "bar \" "   " baz')
      End

      It from end, sub begin
        call search('bar \\" "', 'eW')

        execute 'normal \a'
        Assert Equals(getline(1), '1 foo `bar \" `   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo |bar \" |   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo “bar \" ”   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo ''bar \" ''   " baz')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo "bar \" "   " baz')
      End

      It subs orphaned item even the opposite not found
        call cursor(3, 1)
        call search('"')
        execute 'normal \a'
        Assert Equals(getline(3), '3 orphaned ` land')
        execute 'normal \a'
        Assert Equals(getline(3), '3 orphaned | land')
        execute 'normal \a'
        Assert Equals(getline(3), '3 orphaned “ land')
        execute 'normal \a'
        Assert Equals(getline(3), "3 orphaned ' land")
      End

      It keeps previous visual area untouched
        call cursor(2, 5) " at 2nd line, last 'o' of 'foo'
        execute "normal! vj$\<Esc>"

        call cursor(1, 1)
        call search('"bar')
        execute 'normal \a'
        Assert Equals(getline(1), '1 foo `bar \" `   " baz')

        normal! gv"ay
        Assert Equals(getreg('a', 1, 1), ['o “中文”', '3 orphaned " land'])
      End

      It stays in visual mode if it was
        let line = 'foo "bar \" " baz'

        call setline(1, line)
        call search('"bar') " from begin
        normal! v1lh
        Assert Equals(mode(), 'v')
        execute 'normal \a'
        Assert Equals(getline(1), 'foo `bar \" ` baz')
        Assert Equals(mode(), 'v')
        execute "normal! \<Esc>"

        call setline(1, line)
        call search('" baz') " from end
        normal! v1lh
        Assert Equals(mode(), 'v')
        execute 'normal \a'
        Assert Equals(getline(1), 'foo `bar \" ` baz')
        Assert Equals(mode(), 'v')
      End

      It with multibyte fragment inside
        call cursor(2, 1)
        call search('”')

        execute 'normal \a'
        Assert Equals(getline(2), "2 foo '中文'")
      End
    End

    Context by treesitter range
      Before each
        let lines =<< trim END
          local should_ask = function(_, bufname)
            print("foo bar\" \\\"

            2000 ")
          end
        END
        set filetype=lua
        call setline(1, lines)
      End

      It from begin
        if exists('*v:lua.vim.treesitter.get_parser')
          let parser = luaeval("type(vim.treesitter.get_parser(vim.api.nvim_get_current_buf(), 'lua', {error = false})) == 'table'")
        endif
        " FIXME: this test is incomplete
      End
    End

    Context practical cases
      It JSX string attribute wrap
        call cycle#test#reset_default_groups([
              \   [['=":"', '={`:`}'], 'sub_pairs'],
              \ ])
        let line1 = '<label className="inline-flex items-center">'
        let line2 = '<label className={`inline-flex items-center`}>'
                   " 123456789 123456789 123456789 123456789
                   "                 ^
        call setline(1, line1)
        call search('="')
        execute 'normal \a'
        Assert Equals(getline(1), line2)
        Assert Equals(col('.'), 17)
      End
    End
  End
End
