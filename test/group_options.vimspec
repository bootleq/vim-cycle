Describe Group options
  " Function to simulate 'cond' implementation
  function! s:cond_func(...) abort
    let g:cond_func_called = a:000
    let ret = get(g:, 'cond_func_ret', 0)
    return ret
  endfunction

  Before each
    call cycle#test#reset_default_groups([
          \   [['Yes', 'No'], 'match_case'],
          \   [['GitHub', 'PlayStation'], 'hard_case'],
          \   [['em', 'STRONG'], 'sub_tag'],
          \   [["do:end", "{:}"], 'sub_pairs'],
          \   [[ '[', '<' ], 'sub_pair', {'end_with': [ ']', '>' ]}],
          \   [[ ']', '>' ], 'sub_pair', {'begin_with': [ '[', '<' ]}],
          \   [['on', 'off'], 'match_word'],
          \   [['Mon', 'Tue']],
          \   [['==', '~='], { 'cond': function('s:cond_func') }],
          \   [['==', '!=']],
          \ ])
    new
  End

  After each
    bwipeout!
  End

  It respects "match_case"
    let line = 'yes yEs yeS Yes YES YEs'
    "           123456789 123456789 123
    "                       ^ 13
    call setline(1, line)

    call cursor(1, 1) " yes
    execute 'normal \a'
    Assert Equals(getline(1), line, 'Expect unchaged')

    call cursor(1, 13) " Yes
    execute 'normal \a'
    Assert Equals(getline(1), 'yes yEs yeS No YES YEs')
  End

  It respects "hard_case"
    let line = 'playstation'
    call setline(1, line)

    execute 'normal \a'
    Assert Equals(getline(1), 'GitHub')

    execute 'normal \a'
    Assert Equals(getline(1), 'PlayStation')
  End

  It respects "sub_tag"
    let lines =<< trim END
      <strong id='a'><img src="" />It's
      my<EM> DUTY
        </eM></strong > <eM>
    END
    call setline(1, lines)

    call cursor(1, 4) " In first <strong>, on 'r'
    execute 'normal \a'
    let expected =<< trim END
      <em id='a'><img src="" />It's
      my<EM> DUTY
        </eM></em > <eM>
    END
    Assert Equals(getline(1, '$'), expected, 'Expect <strong> -> <em>')

    call cursor(3, 6) " In line 3, first </eM>, on 'M'
    execute 'normal \a'
    let expected =<< trim END
      <em id='a'><img src="" />It's
      my<sTrong> DUTY
        </sTrong></em > <eM>
    END
    Assert Equals(getline(1, '$'), expected, 'Expect </eM> -> </sTrong>')
  End

  It respects "sub_pair" and "end_with"
    let line = '<= [1, 2, 3] < [a, b, c] -----> >'
               "             B
    call setline(1, line)

    call search('< [a', 'W') " begin of second <
    execute 'normal \a'
    Assert Equals(getline(1), '<= [1, 2, 3] [ [a, b, c] -----] >')
                              "             B                E
    execute 'normal \a'
    Assert Equals(getline(1), line)
  End

  It respects "sub_pair" and "begin_with"
    let line = '<= [1, 2, 3] < [a, b, c] -----> >'
               "                       E
    call setline(1, line)

    call search('] --', 'W') " end of second [ ... ]
    execute 'normal \a'
    Assert Equals(getline(1), '<= [1, 2, 3] < <a, b, c> -----> >')
                              "               B       E
    execute 'normal \a'
    Assert Equals(getline(1), line)
  End

  Context sub_pairs with non-keyword text like LaTex
    Before each
      call cycle#test#reset_default_groups([[
            \   [
            \     '(:)',
            \     '\left(:\right)',
            \     '\mleft(:\mright)',
            \     '\Bigl(:\Bigr)',
            \   ],
            \   'sub_pairs', 'hard_case', 'match_case'
            \ ]])
    End

    It sub_pairs, from begin, sub end
      let line = '(a+b)'
      call setline(1, line)

      execute 'normal \a'
      Assert Equals(getline(1), '\left(a+b\right)')
      execute 'normal \a'
      Assert Equals(getline(1), '\mleft(a+b\mright)')

      call cursor(1, 4) " on 'e' of \mleft
      execute 'normal \a'
      Assert Equals(getline(1), '\Bigl(a+b\Bigr)')
      Assert Equals(col('.'), 4)
    End

    It sub_pairs, from end, sub begin
      let line = '(a+b)'
      call setline(1, line)

      normal! $
      execute 'normal \a'
      Assert Equals(getline(1), '\left(a+b\right)')
      Skip Assert Equals(col('.'), searchpos('\\right')[1], 'Expect cursor at the beginning of \right')
      " FIXME: complete this test
    End
  End

  Describe respects "match_word"
    Before all
      let g:cycle_max_conflict = 100
    End

    After all
      let g:cycle_max_conflict = 1
    End

    It OFF by default, both matched
      call cycle#test#reset_default_groups([
            \   [['on', 'off']],
            \   [['Mon', 'Tue']],
            \ ])

      let line = 'Mon'
                 " ^
      call setline(1, line)

      call cursor(1, 2) " on 'o'
      execute 'normal \a'
      Assert Equals(getline(1), 'Mon', 'Expect unchaged')
      Assert Exists('g:cycle_test_conflict.items')
      Assert Equals(g:cycle_test_conflict.items, ['Tue', 'off'])
    End

    It ON
      call cycle#test#reset_default_groups([
            \   [['on', 'off'], 'match_word'],
            \   [['Mon', 'Tue']],
            \ ])

      let line = 'Mon'
                 " ^
      call setline(1, line)

      call cursor(1, 2) " on 'o'
      execute 'normal \a'
      Assert Equals(getline(1), 'Tue')

      execute 'normal \a'
      Assert Equals(getline(1), line)
    End
  End

  It respects "cond"
    let line = '=='
    call setline(1, line)

    let g:cond_func_ret = 0 " simulate cond returns false
    execute 'normal \a'
    Assert Equals(getline(1), '!=')

    let called = g:cond_func_called
    Assert LengthOf(called, 2)
    Assert IsDict(called[0])
    Assert Equals(called[0].items, ['==', '~='])
    Assert IsDict(called[0].options)
    Assert IsFunction(called[0].options.cond)
    Assert IsNumber(called[1])

    execute 'normal \a'
    Assert Equals(getline(1), '==')

    let g:cond_func_ret = 1 " simulate cond returns true
    execute 'normal \a'
    Assert Equals(getline(1), '~=')

    let called = g:cond_func_called
    Assert LengthOf(called, 2)
    Assert IsDict(called[0])
    Assert Equals(called[0].items, ['==', '~='])
    Assert IsDict(called[0].options)
    Assert IsFunction(called[0].options.cond)
    Assert IsNumber(called[1])
  End
End
