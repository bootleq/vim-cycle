Describe Group options
  " Function to simulate 'cond' implementation
  function! s:cond_func(...) abort
    let g:cond_func_called = a:000
    let ret = get(g:, 'cond_func_ret', 0)
    return ret
  endfunction

  Before each
    call cycle#test#reset_default_groups([
          \   [['Yes', 'No'], 'match_case'],
          \   [['GitHub', 'PlayStation'], 'hard_case'],
          \   [['em', 'STRONG'], 'sub_tag'],
          \   [['on', 'off'], 'match_word'],
          \   [['Mon', 'Tue']],
          \   [['==', '~='], { 'cond': function('s:cond_func') }],
          \   [['==', '!=']],
          \ ])
    " - For sub_pair / sub_pairs, see test/sub_pairs.vimspec
    " - For matcher / changer, see corresponding test cases:
    "   - For regex / replacer, see test/matcher_changer_regex.vimspec
    "   - year, see test/matcher_changer_year.vimspec
    new
  End

  After each
    bwipeout!
  End

  It respects "match_case"
    let line = 'yes yEs yeS Yes YES YEs'
    "           123456789 123456789 123
    "                       ^ 13
    call setline(1, line)

    call cursor(1, 1) " yes
    execute 'normal \a'
    Assert Equals(getline(1), line, 'Expect unchaged')

    call cursor(1, 13) " Yes
    execute 'normal \a'
    Assert Equals(getline(1), 'yes yEs yeS No YES YEs')
  End

  It respects "hard_case"
    let line = 'playstation'
    call setline(1, line)

    execute 'normal \a'
    Assert Equals(getline(1), 'GitHub')

    execute 'normal \a'
    Assert Equals(getline(1), 'PlayStation')
  End

  It respects "sub_tag"
    let lines =<< trim END
      <strong id='a'><img src="" />It's
      my<EM> DUTY
        </eM></strong > <eM>
    END
    call setline(1, lines)

    call cursor(1, 4) " In first <strong>, on 'r'
    execute 'normal \a'
    let expected =<< trim END
      <em id='a'><img src="" />It's
      my<EM> DUTY
        </eM></em > <eM>
    END
    Assert Equals(getline(1, '$'), expected, 'Expect <strong> -> <em>')

    call cursor(3, 6) " In line 3, first </eM>, on 'M'
    execute 'normal \a'
    let expected =<< trim END
      <em id='a'><img src="" />It's
      my<sTrong> DUTY
        </sTrong></em > <eM>
    END
    Assert Equals(getline(1, '$'), expected, 'Expect </eM> -> </sTrong>')
  End

  Describe respects "match_word"
    Before all
      let g:cycle_max_conflict = 100
    End

    After all
      let g:cycle_max_conflict = 1
    End

    It OFF by default, both matched
      call cycle#test#reset_default_groups([
            \   [['on', 'off']],
            \   [['Mon', 'Tue']],
            \ ])

      let line = 'Mon'
                 " ^
      call setline(1, line)

      call cursor(1, 2) " on 'o'
      execute 'normal \a'
      Assert Equals(getline(1), 'Mon', 'Expect unchaged')
      Assert Exists('g:cycle_test_conflict.items')
      Assert Equals(g:cycle_test_conflict.items, ['Tue', 'off'])
    End

    It ON
      call cycle#test#reset_default_groups([
            \   [['on', 'off'], 'match_word'],
            \   [['Mon', 'Tue']],
            \ ])

      let line = 'Mon'
                 " ^
      call setline(1, line)

      call cursor(1, 2) " on 'o'
      execute 'normal \a'
      Assert Equals(getline(1), 'Tue')

      execute 'normal \a'
      Assert Equals(getline(1), line)
    End
  End

  It respects "cond"
    let line = '=='
    call setline(1, line)

    let g:cond_func_ret = 0 " simulate cond returns false
    execute 'normal \a'
    Assert Equals(getline(1), '!=')

    let called = g:cond_func_called
    Assert LengthOf(called, 2)
    Assert IsDict(called[0])
    Assert Equals(called[0].items, ['==', '~='])
    Assert IsDict(called[0].options)
    Assert IsFunction(called[0].options.cond)
    Assert IsNumber(called[1])

    execute 'normal \a'
    Assert Equals(getline(1), '==')

    let g:cond_func_ret = 1 " simulate cond returns true
    execute 'normal \a'
    Assert Equals(getline(1), '~=')

    let called = g:cond_func_called
    Assert LengthOf(called, 2)
    Assert IsDict(called[0])
    Assert Equals(called[0].items, ['==', '~='])
    Assert IsDict(called[0].options)
    Assert IsFunction(called[0].options.cond)
    Assert IsNumber(called[1])
  End
End
